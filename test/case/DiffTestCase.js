import {AbstractTestCase} from './AbstractTestCase.js';
import fs from 'fs';
import {TestConfig} from '../TestConfig.js';
import {ExpectedDiff} from '../expected/ExpectedDiff.js';
import {Preprocessor} from '../../src/io/Preprocessor.js';
import {GeneratorParameters} from '../gen/GeneratorParameters.js';
import {ChangeParameters} from '../gen/ChangeParameters.js';
import {TreeGenerator} from '../gen/TreeGenerator.js';
import {DiffTestResult} from '../result/DiffTestResult.js';

/**
 * Represents a test case for the evaluation of diff algorithms.
 */
export class DiffTestCase extends AbstractTestCase {
  /**
   * The root of the original (old) process tree.
   * @type {Node}
   * @const
   */
  oldTree;
  /**
   * The root of the changed (new) process tree.
   * @type {Node}
   * @const
   */
  newTree;

  /**
   * Construct a new DiffTestCase instance.
   * @param {String} name The name of this test case.
   * @param {Node} oldTree The root of the original process tree.
   * @param {Node} newTree The root of the changed process tree.
   * @param {ExpectedDiff} expected The expected result.
   */
  constructor(
      name,
      oldTree,
      newTree,
      expected,
  ) {
    super(name, expected);
    this.oldTree = oldTree;
    this.newTree = newTree;
  }

  /**
   * Construct a diff test case from a test case directory.
   * @param {String} testCaseDir An absolute or relative path to the test case
   *     directory
   * @return {DiffTestCase} The constructed diff test case
   */
  static from(testCaseDir) {
    const testCaseName = testCaseDir.split('/').pop();
    let oldTree;
    let newTree;
    let expected;
    if (testCaseName.startsWith('gen_')) {
      // Generated test case
      if (!TestConfig.RUN_AUTOGENERATED_TESTS) {
        return null;
      }

      let genParams;
      // change parameters are optional
      let changeParams = new ChangeParameters();
      fs.readdirSync(testCaseDir).forEach((file) => {
        const content = fs.readFileSync(testCaseDir + '/' + file).toString();
        switch (file) {
          case TestConfig.FILENAMES.GEN_PARAMS:
            genParams = Object.assign(
                new GeneratorParameters(),
                JSON.parse(content),
            );
            break;
          case TestConfig.FILENAMES.CHANGE_PARAMS:
            changeParams = Object.assign(
                changeParams,
                JSON.parse(content),
            );
            break;
        }
      },
      );
      // Generator parameters are required
      if (genParams == null) {
        return null;
      }
      const treeGen = new TreeGenerator(genParams);
      oldTree = treeGen.randomTree();
      if (testCaseName === 'gen_leaves_only_shuffled') {
        oldTree = treeGen.leavesOnly();
      }
      return treeGen.changeTree(oldTree, changeParams).testCase;
    } else {
      // Regular test case definition
      const parser = new Preprocessor();
      fs.readdirSync(testCaseDir).forEach((file) => {
        const content = fs.readFileSync(testCaseDir + '/' + file).toString();
        if (file === TestConfig.FILENAMES.NEW_TREE) {
          newTree = parser.parseWithMetadata(content);
        } else if (file === TestConfig.FILENAMES.OLD_TREE) {
          oldTree = parser.parseWithMetadata(content);
        } else if (file === TestConfig.FILENAMES.EXPECTED_DIFF) {
          expected = Object.assign(new ExpectedDiff(), JSON.parse(content));
        }
      });
      // The two process trees are the bare minimum needed for a test case
      if (oldTree == null || newTree == null) {
        return null;
      }
    }
    if (expected == null) {
      expected = new ExpectedDiff();
    }
    return new DiffTestCase(
        testCaseName,
        oldTree,
        newTree,
        expected,
    );
  }

  /**
   * Complete this test case.
   * @param {String} algorithm The algorithm that ran this case.
   * @param {Number} runtime The time (in ms) the algorithm took to complete
   *     the case.
   * @param {ActualDiff|null} actual The diff produced by the algorithm, null
   *     indicates failure.
   * @param {String} verdict The verdict for this test case and algorithm.
   * @return {DiffTestResult} The corresponding result.
   */
  complete(
      algorithm,
      runtime,
      actual = null,
      verdict,
  ) {
    return new DiffTestResult(
        this.name,
        algorithm,
        runtime,
        actual,
        verdict,
    );
  }
}


