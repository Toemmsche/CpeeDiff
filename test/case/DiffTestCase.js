/*
    Copyright 2021 Tom Papke

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

import {AbstractTestCase} from "./AbstractTestCase.js";
import fs from "fs";
import {TestConfig} from "../TestConfig.js";
import {DiffTestInfo} from "./DiffTestInfo.js";
import {Preprocessor} from "../../src/io/Preprocessor.js";
import {GeneratorParameters} from "../gen/GeneratorParameters.js";
import {ChangeParameters} from "../gen/ChangeParameters.js";
import {TreeGenerator} from "../gen/TreeGenerator.js";
import {Logger} from "../../Logger.js";
import {DiffTestResult} from "../diff_eval/DiffTestResult.js";

/**
 * Represents a test case for the evaluation of diff algorithms.
 * @property {Node} oldTree The root of the original process tree
 * @property {Node} newTree The root of the changed process tree
 * @property {DiffTestInfo} info Additional information about the test case like the maximum tree size
 * and the number and distribution of edit operations applied.
 */
export class DiffTestCase extends AbstractTestCase {

    oldTree;
    newTree;
    info;


    /**
     * Construct a new diff test case
     * @param {Node} oldTree The root of the original process tree
     * @param {Node} newTree The root of the changed process tree
     * @param {DiffTestInfo} info Additional information about the test case
     */
    constructor(oldTree, newTree, info) {
        super();
        this.oldTree = oldTree;
        this.newTree = newTree;
        this.info = info;
    }

    /**
     * Construct a diff test case from a test case directory.
     * @param {String} directory An absolute or relative path to the test case directory
     * @return DiffTestCase The constructed diff test case
     */
    static from(testCaseDir) {
        const testCaseName = testCaseDir.split("/").pop();
        let oldTree, newTree, testInfo;
        if (testCaseName.startsWith("gen_")) {
            //Generated test case
            if (!TestConfig.RUN_AUTOGENERATED_TESTS) {
                return null;
            }

            let genParams;
            //change parameters are optional
            let changeParams = new ChangeParameters();
            fs.readdirSync(testCaseDir).forEach((file) => {
                    const content = fs.readFileSync(testCaseDir + "/" + file).toString();
                    switch (file) {
                        case TestConfig.GEN_PARAMS_FILENAME:
                            genParams = Object.assign(new GeneratorParameters(), JSON.parse(content));
                            break;
                        case TestConfig.CHANGE_PARAMS_FILENAME:
                            changeParams = Object.assign(changeParams, JSON.parse(content));
                            break;
                    }
                }
            );
            //Generator parameters are required
            if (genParams == null) {
                return null;
            }

            const treeGen = new TreeGenerator(genParams);
            switch (testCaseName) {
                case "gen_totally_different": {
                    Logger.info("Generating two unrelated process trees", this);
                    oldTree = treeGen.randomTree();
                    newTree = treeGen.randomTree();
                    testInfo = new DiffTestInfo(testCaseName, Math.max(newTree.size(), oldTree.size()));
                    break;
                }
                default: {
                    //TODO
                    oldTree = treeGen.randomTree();
                    if (testCaseName === "gen_leaves_only_shuffled") {
                        oldTree = treeGen.randomLeavesOnly();
                    }
                    const changedInfo = treeGen.changeTree(oldTree, changeParams);
                    newTree = changedInfo.tree;
                    testInfo = changedInfo.info;
                    break;
                }
            }
            testInfo.name = testCaseName;
        } else {
            //Regular test case definition
            const parser = new Preprocessor();
            fs.readdirSync(testCaseDir).forEach((file) => {
                    const content = fs.readFileSync(testCaseDir + "/" + file).toString();
                    if (file === TestConfig.NEW_TREE_FILENAME) {
                        newTree = parser.parseWithMetadata(content);
                    } else if (file === TestConfig.OLD_TREE_FILENAME) {
                        oldTree = parser.parseWithMetadata(content);
                    } else if (file === TestConfig.DIFF_INFO_FILENAME) {
                        testInfo = Object.assign(new DiffTestInfo(), JSON.parse(content));
                    }
                }
            );
            //The two process trees are the bare minimum needed for a test case
            if (oldTree == null || newTree == null) {
                return null;
            }
            if (testInfo == null) {
                testInfo = new DiffTestInfo();
            }
            testInfo.name = testCaseName;
            testInfo.maxSize = Math.max(oldTree.size(), newTree.size());
        }
        return new DiffTestCase(oldTree, newTree, testInfo);
    }

    /**
     * Fail this test case.
     * @param {DiffAdapter} algorithm The algorithm that failed for this case
     * @return DiffTestResult A result indicating failure
     */
    fail(algorithm) {
        return new DiffTestResult(this.info, algorithm, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED, TestConfig.VERDICTS.FAILED);
    }

    /**
     * Time out for this test case.
     * @param {DiffAdapter} algorithm The algorithm that timed out for this case
     * @return DiffTestResult A result indicating a timeout
     */
    timeout(algorithm) {
        return new DiffTestResult(this.info, algorithm, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT, TestConfig.VERDICTS.TIMEOUT);
    }
}


